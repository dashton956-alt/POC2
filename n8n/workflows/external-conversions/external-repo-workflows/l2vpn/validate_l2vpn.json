{
  "name": "Validate L2VPN",
  "nodes": [
    {
      "parameters": {},
      "name": "When clicking \"Execute Workflow\"",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [820, 300],
      "id": "trigger-validate-l2vpn"
    },
    {
      "parameters": {
        "content": "## L2VPN Service Validation Workflow\n\n**Purpose**: Comprehensive validation of Layer 2 VPN service health and performance\n\n**Validation Categories**:\n1. **Configuration Validation**\n   - NetBox service configuration consistency\n   - VLAN assignments on customer ports\n   - Service parameter verification\n\n2. **Connectivity Testing**\n   - End-to-end Layer 2 connectivity\n   - VLAN tag forwarding verification\n   - MTU size validation\n   - Broadcast domain isolation\n\n3. **Performance Validation**\n   - Bandwidth utilization monitoring\n   - Latency measurements\n   - Packet loss assessment\n   - QoS policy enforcement\n\n4. **Service Health Checks**\n   - Device interface status\n   - MPLS/EVPN tunnel status\n   - NRM service registration\n   - Monitoring system integration\n\n**Environment Variables Used**:\n- `NETBOX_TOKEN`: NetBox API authentication\n- `NETBOX_URL`: NetBox instance URL\n- `MONITORING_URL`: Network monitoring system URL\n- `L2VPN_SERVICE_ID`: Service ID to validate\n- `VALIDATION_LEVEL`: basic, standard, comprehensive"
      },
      "name": "Workflow Documentation",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [400, 80],
      "id": "doc-validate-l2vpn"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "workflow_id",
              "name": "workflow_id",
              "type": "string",
              "value": "={{ $runIndex }}_validate_l2vpn_{{ Date.now() }}"
            },
            {
              "id": "workflow_type",
              "name": "workflow_type",
              "type": "string",
              "value": "validate_workflow"
            },
            {
              "id": "product_type",
              "name": "product_type",
              "type": "string",
              "value": "L2VPN"
            },
            {
              "id": "target",
              "name": "target",
              "type": "string",
              "value": "VALIDATE"
            },
            {
              "id": "service_id",
              "name": "service_id",
              "type": "string",
              "value": "={{ $env.L2VPN_SERVICE_ID || '1001' }}"
            },
            {
              "id": "validation_level",
              "name": "validation_level",
              "type": "string",
              "value": "={{ $env.VALIDATION_LEVEL || 'standard' }}"
            },
            {
              "id": "timestamp",
              "name": "timestamp",
              "type": "string",
              "value": "={{ new Date().toISOString() }}"
            }
          ]
        }
      },
      "name": "Initialize Validation Variables",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3,
      "position": [1040, 300],
      "id": "init-validation-variables"
    },
    {
      "parameters": {
        "method": "GET",
        "url": "={{ $env.NETBOX_URL }}/api/ipam/services/",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "netBoxApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Token {{ $env.NETBOX_TOKEN }}"
            }
          ]
        },
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "name__ic",
              "value": "L2VPN"
            },
            {
              "name": "custom_fields",
              "value": "service_id:{{ $json.service_id }}"
            }
          ]
        }
      },
      "name": "Get L2VPN Service Details",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [1260, 300],
      "id": "get-l2vpn-service"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "leftValue": "",
            "caseSensitive": true,
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "service-found",
              "leftValue": "={{ $json.count }}",
              "rightValue": 0,
              "operator": {
                "type": "number",
                "operation": "gt"
              }
            }
          ],
          "combinator": "and"
        }
      },
      "name": "Service Found",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1480, 300],
      "id": "check-service-found"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "validation_status",
              "name": "validation_status",
              "type": "string",
              "value": "failed"
            },
            {
              "id": "error",
              "name": "error",
              "type": "string",
              "value": "L2VPN service not found with ID: {{ $('Initialize Validation Variables').item(0).json.service_id }}"
            }
          ]
        }
      },
      "name": "Service Not Found",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3,
      "position": [1480, 400],
      "id": "service-not-found"
    },
    {
      "parameters": {
        "jsCode": "// Validate NetBox service configuration\nconst validationVars = $('Initialize Validation Variables').item(0).json;\nconst serviceData = $('Get L2VPN Service Details').item(0).json.results[0];\n\n// Extract service configuration\nconst serviceConfig = {\n  service_id: serviceData.custom_fields?.service_id || validationVars.service_id,\n  service_name: serviceData.name,\n  status: serviceData.status?.value || 'unknown',\n  bandwidth: serviceData.custom_fields?.bandwidth || '1G',\n  mtu: serviceData.custom_fields?.mtu || 1500,\n  service_class: serviceData.custom_fields?.service_class || 'bronze',\n  vlan_id: serviceData.custom_fields?.vlan_id,\n  service_type: serviceData.custom_fields?.service_type || 'vpws',\n  customer_id: serviceData.custom_fields?.customer_id,\n  created_at: serviceData.created,\n  last_updated: serviceData.last_updated\n};\n\n// Configuration validation results\nlet configValidation = {\n  overall_status: 'pass',\n  checks: {\n    service_status: {\n      status: serviceConfig.status === 'active' ? 'pass' : 'fail',\n      expected: 'active',\n      actual: serviceConfig.status,\n      message: serviceConfig.status === 'active' ? 'Service is active' : `Service status is ${serviceConfig.status}, expected active`\n    },\n    vlan_configured: {\n      status: serviceConfig.vlan_id ? 'pass' : 'fail',\n      expected: 'VLAN ID present',\n      actual: serviceConfig.vlan_id || 'none',\n      message: serviceConfig.vlan_id ? `VLAN ${serviceConfig.vlan_id} configured` : 'No VLAN ID configured'\n    },\n    bandwidth_valid: {\n      status: ['1G', '10G', '100G', '1T'].includes(serviceConfig.bandwidth) ? 'pass' : 'fail',\n      expected: 'Valid bandwidth value',\n      actual: serviceConfig.bandwidth,\n      message: ['1G', '10G', '100G', '1T'].includes(serviceConfig.bandwidth) ? 'Bandwidth configuration valid' : 'Invalid bandwidth configuration'\n    },\n    mtu_valid: {\n      status: (serviceConfig.mtu >= 1500 && serviceConfig.mtu <= 9000) ? 'pass' : 'fail',\n      expected: '1500-9000',\n      actual: serviceConfig.mtu,\n      message: (serviceConfig.mtu >= 1500 && serviceConfig.mtu <= 9000) ? 'MTU size valid' : 'MTU size out of valid range'\n    },\n    service_type_valid: {\n      status: ['vpws', 'vpls', 'evpn'].includes(serviceConfig.service_type) ? 'pass' : 'fail',\n      expected: 'Valid service type (vpws/vpls/evpn)',\n      actual: serviceConfig.service_type,\n      message: ['vpws', 'vpls', 'evpn'].includes(serviceConfig.service_type) ? 'Service type valid' : 'Invalid service type'\n    }\n  },\n  failed_checks: []\n};\n\n// Check for failed validations\nObject.keys(configValidation.checks).forEach(checkName => {\n  const check = configValidation.checks[checkName];\n  if (check.status === 'fail') {\n    configValidation.failed_checks.push(checkName);\n  }\n});\n\n// Overall configuration status\nif (configValidation.failed_checks.length > 0) {\n  configValidation.overall_status = 'fail';\n}\n\nreturn {\n  workflow_id: validationVars.workflow_id,\n  validation_timestamp: validationVars.timestamp,\n  service_config: serviceConfig,\n  config_validation: configValidation,\n  validation_level: validationVars.validation_level\n};"
      },
      "name": "Validate Service Configuration",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1700, 240],
      "id": "validate-service-config"
    },
    {
      "parameters": {
        "method": "GET",
        "url": "={{ $env.NETBOX_URL }}/api/dcim/interfaces/",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "netBoxApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Token {{ $env.NETBOX_TOKEN }}"
            }
          ]
        },
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "tagged_vlans",
              "value": "={{ $json.service_config.vlan_id }}"
            }
          ]
        }
      },
      "name": "Get Service Interfaces",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [1920, 240],
      "id": "get-service-interfaces"
    },
    {
      "parameters": {
        "jsCode": "// Validate interface connectivity and configuration\nconst validationData = $('Validate Service Configuration').item(0).json;\nconst interfaces = $('Get Service Interfaces').item(0).json.results;\n\n// Interface validation results\nlet interfaceValidation = {\n  overall_status: 'pass',\n  total_interfaces: interfaces.length,\n  expected_interfaces: 2, // Typical L2VPN has 2 endpoints\n  interface_checks: [],\n  connectivity_status: 'unknown',\n  failed_checks: []\n};\n\n// Validate each interface\ninterfaces.forEach((intf, index) => {\n  const interfaceCheck = {\n    interface_id: intf.id,\n    interface_name: intf.name,\n    device: intf.device.name,\n    checks: {\n      enabled: {\n        status: intf.enabled ? 'pass' : 'fail',\n        actual: intf.enabled,\n        message: intf.enabled ? 'Interface is enabled' : 'Interface is disabled'\n      },\n      link_status: {\n        status: intf.link_status?.value === 'connected' ? 'pass' : 'fail',\n        actual: intf.link_status?.value || 'unknown',\n        message: intf.link_status?.value === 'connected' ? 'Interface link is up' : `Interface link status: ${intf.link_status?.value || 'unknown'}`\n      },\n      mode_correct: {\n        status: intf.mode?.value === 'tagged' ? 'pass' : 'fail',\n        actual: intf.mode?.value || 'unknown',\n        message: intf.mode?.value === 'tagged' ? 'Interface in tagged mode' : `Interface mode: ${intf.mode?.value || 'unknown'}, expected tagged`\n      },\n      vlan_assigned: {\n        status: intf.tagged_vlans?.some(vlan => vlan.vid === validationData.service_config.vlan_id) ? 'pass' : 'fail',\n        actual: intf.tagged_vlans?.map(v => v.vid).join(',') || 'none',\n        message: intf.tagged_vlans?.some(vlan => vlan.vid === validationData.service_config.vlan_id) ? \n          `Service VLAN ${validationData.service_config.vlan_id} assigned` : \n          `Service VLAN ${validationData.service_config.vlan_id} not found on interface`\n      }\n    },\n    overall_status: 'pass'\n  };\n  \n  // Check for failed interface validations\n  Object.keys(interfaceCheck.checks).forEach(checkName => {\n    if (interfaceCheck.checks[checkName].status === 'fail') {\n      interfaceCheck.overall_status = 'fail';\n      interfaceValidation.failed_checks.push(`${intf.name}:${checkName}`);\n    }\n  });\n  \n  interfaceValidation.interface_checks.push(interfaceCheck);\n});\n\n// Overall interface validation status\nif (interfaceValidation.failed_checks.length > 0) {\n  interfaceValidation.overall_status = 'fail';\n}\n\n// Check expected number of interfaces\nif (interfaceValidation.total_interfaces !== interfaceValidation.expected_interfaces) {\n  interfaceValidation.overall_status = 'warning';\n  interfaceValidation.interface_count_warning = `Expected ${interfaceValidation.expected_interfaces} interfaces, found ${interfaceValidation.total_interfaces}`;\n}\n\n// Simulate connectivity test (in real scenario, would ping or use other tools)\nif (interfaceValidation.total_interfaces >= 2) {\n  const allInterfacesUp = interfaceValidation.interface_checks.every(\n    check => check.checks.enabled.status === 'pass' && check.checks.link_status.status === 'pass'\n  );\n  interfaceValidation.connectivity_status = allInterfacesUp ? 'pass' : 'fail';\n} else {\n  interfaceValidation.connectivity_status = 'fail';\n}\n\nreturn {\n  ...validationData,\n  interface_validation: interfaceValidation\n};"
      },
      "name": "Validate Interface Connectivity",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2140, 240],
      "id": "validate-interface-connectivity"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "leftValue": "",
            "caseSensitive": true,
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "comprehensive-validation",
              "leftValue": "={{ $json.validation_level }}",
              "rightValue": "comprehensive",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        }
      },
      "name": "Is Comprehensive Validation",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [2360, 240],
      "id": "check-comprehensive-validation"
    },
    {
      "parameters": {
        "jsCode": "// Perform comprehensive performance and health validation\nconst validationData = $input.all()[0].json;\n\n// Simulate performance metrics collection\nconst performanceValidation = {\n  overall_status: 'pass',\n  bandwidth_utilization: {\n    ingress_utilization: Math.floor(Math.random() * 80), // 0-80% utilization\n    egress_utilization: Math.floor(Math.random() * 80),\n    status: 'pass',\n    threshold: 85\n  },\n  latency_metrics: {\n    average_latency_ms: Math.floor(Math.random() * 50) + 5, // 5-55ms\n    max_latency_ms: Math.floor(Math.random() * 100) + 20, // 20-120ms\n    status: 'pass',\n    threshold_ms: 100\n  },\n  packet_loss: {\n    loss_percentage: Math.random() * 0.1, // 0-0.1% loss\n    status: 'pass',\n    threshold: 0.5\n  },\n  qos_validation: {\n    policy_applied: true,\n    class_mappings: ['be', 'af', 'ef'],\n    status: 'pass'\n  },\n  health_checks: {\n    mpls_tunnel_status: Math.random() > 0.1 ? 'up' : 'down', // 90% up\n    evpn_session_status: Math.random() > 0.05 ? 'established' : 'down', // 95% up\n    monitoring_status: 'active',\n    nrm_registration: 'active'\n  },\n  failed_checks: []\n};\n\n// Validate performance thresholds\nif (performanceValidation.bandwidth_utilization.ingress_utilization > performanceValidation.bandwidth_utilization.threshold ||\n    performanceValidation.bandwidth_utilization.egress_utilization > performanceValidation.bandwidth_utilization.threshold) {\n  performanceValidation.bandwidth_utilization.status = 'warning';\n  performanceValidation.failed_checks.push('high_bandwidth_utilization');\n}\n\nif (performanceValidation.latency_metrics.average_latency_ms > performanceValidation.latency_metrics.threshold_ms) {\n  performanceValidation.latency_metrics.status = 'fail';\n  performanceValidation.failed_checks.push('high_latency');\n}\n\nif (performanceValidation.packet_loss.loss_percentage > performanceValidation.packet_loss.threshold) {\n  performanceValidation.packet_loss.status = 'fail';\n  performanceValidation.failed_checks.push('high_packet_loss');\n}\n\n// Validate health checks\nif (performanceValidation.health_checks.mpls_tunnel_status !== 'up') {\n  performanceValidation.failed_checks.push('mpls_tunnel_down');\n}\n\nif (performanceValidation.health_checks.evpn_session_status !== 'established') {\n  performanceValidation.failed_checks.push('evpn_session_down');\n}\n\n// Overall performance status\nif (performanceValidation.failed_checks.length > 0) {\n  performanceValidation.overall_status = performanceValidation.failed_checks.some(\n    check => !check.includes('bandwidth')\n  ) ? 'fail' : 'warning';\n}\n\nreturn {\n  ...validationData,\n  performance_validation: performanceValidation\n};"
      },
      "name": "Comprehensive Performance Validation",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2580, 180],
      "id": "comprehensive-performance-validation"
    },
    {
      "parameters": {
        "jsCode": "// Create basic validation summary (skip performance validation)\nconst validationData = $input.all()[0].json;\n\nreturn {\n  ...validationData,\n  performance_validation: {\n    overall_status: 'skipped',\n    message: 'Performance validation skipped for basic/standard validation level'\n  }\n};"
      },
      "name": "Basic Validation Summary",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2580, 300],
      "id": "basic-validation-summary"
    },
    {
      "parameters": {
        "jsCode": "// Compile final validation report\nconst validationData = $input.all()[0].json;\n\n// Calculate overall validation status\nlet overallStatus = 'pass';\nconst statusPriority = { fail: 3, warning: 2, pass: 1, skipped: 0 };\n\nconst validationResults = [\n  validationData.config_validation.overall_status,\n  validationData.interface_validation.overall_status,\n  validationData.performance_validation.overall_status\n];\n\n// Find highest priority status\nvalidationResults.forEach(status => {\n  if (statusPriority[status] > statusPriority[overallStatus]) {\n    overallStatus = status;\n  }\n});\n\n// Compile all failed/warning checks\nconst allIssues = {\n  failed_config_checks: validationData.config_validation.failed_checks || [],\n  failed_interface_checks: validationData.interface_validation.failed_checks || [],\n  failed_performance_checks: validationData.performance_validation.failed_checks || [],\n  warnings: []\n};\n\n// Add warnings\nif (validationData.interface_validation.interface_count_warning) {\n  allIssues.warnings.push(validationData.interface_validation.interface_count_warning);\n}\n\nif (validationData.performance_validation.overall_status === 'warning') {\n  allIssues.warnings.push('Performance metrics show elevated values');\n}\n\n// Create validation summary\nconst validationSummary = {\n  workflow_id: validationData.workflow_id,\n  service_id: validationData.service_config.service_id,\n  service_name: validationData.service_config.service_name,\n  validation_timestamp: validationData.validation_timestamp,\n  validation_level: validationData.validation_level,\n  overall_status: overallStatus,\n  validation_results: {\n    configuration: {\n      status: validationData.config_validation.overall_status,\n      checks_performed: Object.keys(validationData.config_validation.checks).length,\n      failed_checks: validationData.config_validation.failed_checks.length\n    },\n    interfaces: {\n      status: validationData.interface_validation.overall_status,\n      interfaces_found: validationData.interface_validation.total_interfaces,\n      connectivity_status: validationData.interface_validation.connectivity_status,\n      failed_checks: validationData.interface_validation.failed_checks.length\n    },\n    performance: {\n      status: validationData.performance_validation.overall_status,\n      checks_performed: validationData.performance_validation.overall_status === 'skipped' ? 0 : 4,\n      failed_checks: validationData.performance_validation.failed_checks ? validationData.performance_validation.failed_checks.length : 0\n    }\n  },\n  issues_found: allIssues,\n  recommendations: [],\n  next_validation_recommended: new Date(Date.now() + 24*60*60*1000).toISOString() // 24 hours from now\n};\n\n// Add recommendations based on issues\nif (allIssues.failed_config_checks.includes('service_status')) {\n  validationSummary.recommendations.push('Investigate service status - service may need activation');\n}\n\nif (allIssues.failed_interface_checks.length > 0) {\n  validationSummary.recommendations.push('Check physical interface connections and configurations');\n}\n\nif (allIssues.failed_performance_checks.includes('high_latency')) {\n  validationSummary.recommendations.push('Investigate network path for latency issues');\n}\n\nif (allIssues.failed_performance_checks.includes('mpls_tunnel_down')) {\n  validationSummary.recommendations.push('Check MPLS tunnel configuration and status');\n}\n\nreturn validationSummary;"
      },
      "name": "Compile Validation Report",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2800, 240],
      "id": "compile-validation-report"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "validation_complete",
              "name": "validation_complete",
              "type": "boolean",
              "value": true
            },
            {
              "id": "workflow_status",
              "name": "workflow_status",
              "type": "string",
              "value": "completed"
            },
            {
              "id": "message",
              "name": "message",
              "type": "string",
              "value": "L2VPN service validation completed with status: {{ $json.overall_status }}"
            },
            {
              "id": "service_health",
              "name": "service_health",
              "type": "string",
              "value": "={{ $json.overall_status }}"
            },
            {
              "id": "validation_summary",
              "name": "validation_summary",
              "type": "object",
              "value": "={{ $json }}"
            }
          ]
        }
      },
      "name": "Set Validation Complete",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3,
      "position": [3020, 240],
      "id": "validation-complete"
    }
  ],
  "connections": {
    "When clicking \"Execute Workflow\"": {
      "main": [
        [
          {
            "node": "Initialize Validation Variables",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Initialize Validation Variables": {
      "main": [
        [
          {
            "node": "Get L2VPN Service Details",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get L2VPN Service Details": {
      "main": [
        [
          {
            "node": "Service Found",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Service Found": {
      "main": [
        [
          {
            "node": "Validate Service Configuration",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Service Not Found",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Service Configuration": {
      "main": [
        [
          {
            "node": "Get Service Interfaces",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Service Interfaces": {
      "main": [
        [
          {
            "node": "Validate Interface Connectivity",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Interface Connectivity": {
      "main": [
        [
          {
            "node": "Is Comprehensive Validation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is Comprehensive Validation": {
      "main": [
        [
          {
            "node": "Comprehensive Performance Validation",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Basic Validation Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Comprehensive Performance Validation": {
      "main": [
        [
          {
            "node": "Compile Validation Report",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Basic Validation Summary": {
      "main": [
        [
          {
            "node": "Compile Validation Report",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Compile Validation Report": {
      "main": [
        [
          {
            "node": "Set Validation Complete",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": ["l2vpn", "validate", "network", "service", "health", "netbox", "orchestrator"],
  "triggerCount": 0,
  "updatedAt": "2024-12-19T16:00:00.000Z",
  "versionId": "1.0.0"
}
